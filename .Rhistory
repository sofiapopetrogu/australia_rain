theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size =10))
plot_list <- append(plot_list, list(density_plot))
}
}
install.packages("scales")
library(corrplot)
library(ggplot2)
library(caret)
library(magrittr)
library(gridExtra)
library(scales)
for (col in column_names) {
if (col == "RainToday") {
# Plot the barplot
bar_plot <- ggplot(count_df, aes(x = Value, y = Count, fill = Feature)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Feature", y = "Count", fill = "") +
scale_fill_manual(values = c(pastel_pal()(2)), labels = c("RainToday", "RainTomorrow")) +
theme_minimal()
plot_list <- append(plot_list, list(bar_plot))
}
else {
density_plot <- rain%>% ggplot(aes(x = .data[[col]] , fill = factor(RainTomorrow))) +
geom_density(alpha = 0.5) +
labs(x = col, y = "Density", fill = "RainTomorrow") +
ggtitle(paste("Density Plot of ", col, "by Raintomorrow")) +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size =10))
plot_list <- append(plot_list, list(density_plot))
}
}
plot_list <- list()
for (col in column_names) {
if (col == "RainToday") {
# Plot the barplot
bar_plot <- ggplot(count_df, aes(x = Value, y = Count, fill = Feature)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Feature", y = "Count", fill = "") +
scale_fill_manual(values = c("red", "blue"), labels = c("RainToday", "RainTomorrow")) +
theme_minimal()
plot_list <- append(plot_list, list(bar_plot))
}
else {
density_plot <- rain%>% ggplot(aes(x = .data[[col]] , fill = factor(RainTomorrow))) +
geom_density(alpha = 0.5) +
labs(x = col, y = "Density", fill = "RainTomorrow") +
ggtitle(paste("Density Plot of ", col, "by Raintomorrow")) +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size =10))
plot_list <- append(plot_list, list(density_plot))
}
grid.arrange(grobs = plot_list, nrow = 3, ncol = 2)
print(plot_list)
}
grid.arrange(grobs = plot_list, nrow = 3, ncol = 2)
prop.table(table(rain$RainTomorrow))
install.packages("DMwR2")
install.packages("DMwR")
library(DMwR2)
newData <- SMOTE(rain$RainTomorrow ~ ., rain, perc.over = 100,perc.under=300)
library(DMwR2)
newData <- SMOTE(rain$RainTomorrow ~ ., rain, perc.over = 100,perc.under=300)
library(DMwR)
u <- "https://cran.r-project.org/src/contrib/Archive/DMwR/DMwR_0.4.1.tar.gz"
install.packages(u)
library(DMwR)
install.packages("~/Desktop/Rain_Australia/DMwR_0.4.1.tar.gz", repos = NULL, type = "source")
install.packages("abind")
install.packages("ROCR")
u <- "https://cran.r-project.org/src/contrib/Archive/DMwR/DMwR_0.4.1.tar.gz"
install.packages(u)
library(DMwR)
newData <- SMOTE(rain$RainTomorrow ~ ., rain, perc.over = 100,perc.under=300)
newData <- SMOTE(rain$RainTomorrow ~ ., rain, perc.over = 100,perc.under=300)
balancedRAIN <- SmoteClassif(rain$RainTomorrow ~ ., rain[], C.perc = "balance", dist="HEOM")
balancedRAIN <- SMOTEClassif(rain$RainTomorrow ~ ., rain[], C.perc = "balance", dist="HEOM")
install.packages("UBL")
library(UBL)
balancedRAIN <- SmoteClassif(rain$RainTomorrow ~ ., rain[], C.perc = "balance", dist="HEOM")
table(balancedRAIN$RainTomorrow)
table(rain$RainTomorrow)
table(balancedRAIN$RainTomorrow)
newData <- SMOTE(rain$RainTomorrow ~ ., rain, perc.over = 100,perc.under=300)
View(grid_size)
View(balancedRAIN)
newData <- SMOTE(factor(rain$RainTomorrow) ~ ., rain, perc.over = 100,perc.under=300)
newData <- SMOTE(as.factor(rain$RainTomorrow) ~ ., rain, perc.over = 100,perc.under=300)
newData <- SMOTE(as.factor(rain$RainTomorrow) ~ ., rain, perc.over = 100,perc.under=300)
newData <- SMOTE(as.factor(rain$RainTomorrow) ~ ., rain, perc.over = 100,perc.under=300)
install.packages("caret")
library(caret)
under <- downSample(x = rain[, -1], y = rain[, 1])
table(under$RainTomorrow)
head(under)
under <- downSample(x = rain[, -1], y = rain[[RainTomorrow]])
under <- downSample(x = rain[, -1], y = rain[["RainTomorrow"]])
under <- downSample(x = rain[, -1], y = factor(rain[["RainTomorrow"]])
head(under)
under <- downSample(x = rain[, -1], y = factor(rain[["RainTomorrow"]]))
under <- downSample(x = rain[, -1], y = factor(rain[["RainTomorrow"]]))
head(under)
table(under$RainTomorrow)
install.packages("MASS")
library(MASS)
library(MASS)
library(MASS)
library(corrplot)
library(ggplot2)
library(caret)
library(magrittr)
library(gridExtra)
library(scales)
library(DMwR)
library(UBL)
library(caret)
library(MASS)
library(ipred)
file_path <- "/Users/Sofia/Desktop/Rain_Australia/weatherAUS.csv"
rain <- read.csv(file_path)
head(rain)
summary(rain)
# Find Empty Columns
empty_columns <- which(colSums(is.na(rain)) == nrow(rain))
names_of_empty_col<- names(rain)[empty_columns]
names_of_empty_col
dim(rain)
# Omit rows with NAs. We are left with 56,420 rows and 23 columns
rain <- na.omit(rain)
print(rain)
rain$RainToday <- ifelse(rain$RainToday == "Yes", 1,
ifelse(rain$RainToday == "No", 0, rain$RainToday))
#RainTomorrow is our Target variable
rain$RainTomorrow <- ifelse(rain$RainTomorrow == "Yes", 1,
ifelse(rain$RainTomorrow == "No", 0, rain$RainToday))
#Remove date and location columns and hot encode wind directions
rain <- rain[, !(names(rain) %in% c('Date', 'Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm'))]
# 56,420 Ã— 18
head(rain)
rain <- as.data.frame(lapply(rain, as.numeric))
print(summary(rain))
# Build a Correlation Matrix
cor_matrix <- cor(rain)
# Create a heatmap from the correlation matrix with blue, white, and green color scheme
heatmap(cor_matrix, col = colorRampPalette(c("blue", "white", "green"))(100))
# Add a color legend
legend_colors <- c("blue", "white", "green")
legend("right", legend = c(-1, 0, 1), fill = legend_colors, title = "Correlation")
# Add a main title
title(main = "Correlation Heatmap")
corrplot <- corrplot(cor(rain[,-19]),
method = "number",
diag = TRUE,
tl.cex = 0.4,
number.cex = 0.5,
tl.col = "black")
## Find features with highest correlation with target variable (RainTomorrow)
correlations <- cor_matrix['RainTomorrow',]
highly_correlated_columns <- correlations[abs(correlations) > 0.3 & correlations != 1]
column_names <- names(highly_correlated_columns)
print(column_names)
rain_subset <- rain[,c(column_names)]
# We are trying to visualize relationship between Target Variable, RainTomorrow with the features having the highest correlation
# Calculate the count of each feature
count_rain_today <- sum(rain$RainToday == 1)
count_no_rain_today <- sum(rain$RainToday == 0)
count_rain_tomorrow <- sum(rain$RainTomorrow == 1)
count_no_rain_tomorrow <- sum(rain$RainTomorrow == 0)
# Create a data frame with the counts
count_df <- data.frame(
Feature = c("RainToday", "RainTomorrow", "RainToday","RainTomorrow"),
Value = c("1", "1", "0", "0"),
Count = c(count_rain_today, count_rain_tomorrow, count_no_rain_today, count_no_rain_tomorrow)
)
plot_list <- list()
for (col in column_names) {
if (col == "RainToday") {
# Plot the barplot
bar_plot <- ggplot(count_df, aes(x = Value, y = Count, fill = Feature)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Feature", y = "Count", fill = "") +
scale_fill_manual(values = c("red", "blue"), labels = c("RainToday", "RainTomorrow")) +
theme_minimal()
plot_list <- append(plot_list, list(bar_plot))
}
else {
density_plot <- rain%>% ggplot(aes(x = .data[[col]] , fill = factor(RainTomorrow))) +
geom_density(alpha = 0.5) +
labs(x = col, y = "Density", fill = "RainTomorrow") +
ggtitle(paste("Density Plot of ", col, "by Raintomorrow")) +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size =10))
plot_list <- append(plot_list, list(density_plot))
}
}
print(plot_list)
grid.arrange(grobs = plot_list, nrow = 3, ncol = 2)
# Sunshine: fraction of total days having higher sunshine record more 0 RainTomorrow, lower sunshine, more 1 RainTomorrow
# Humidity3pm: overlap more but still higher humidity associated with 1 RainTomorrow and vice versa
#Cloud9am/Cloud3pm: oscillates a bit across x-axis with higher discrepancies between RainTomorrow values at the two extremes.
#RainToday: Since RainToday is a binary variable, the density plots are concentrated around 0 and 1. When RainToday =0, there is a bigger discrepancy between 0 and 1 for RainTomorrow.
# Check distribution of RainTomorrow values to see how balanced the data is
# 0: 43993; 1: 12427
table(rain$RainTomorrow)
# Handling balancing of data below in train/test split
# Feature Scaling
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
rain_n <- as.data.frame(lapply(rain[,1:16], min_max_norm))
#Add back in Binary Feature, RainToday and target variable
rain_n$RainToday <- rain$RainToday
rain_n$RainTomorrow <- rain$RainTomorrow
prop.table(table(rain$RainTomorrow))
balancedRAIN <- SmoteClassif(rain$RainTomorrow ~ ., rain[], C.perc = "balance", dist="HEOM")
table(rain$RainTomorrow)
table(balancedRAIN$RainTomorrow)
under <- downSample(x = rain[, -1], y = factor(rain[["RainTomorrow"]]))
table(under$RainTomorrow)
rain_balanced <- downSample(x = rain[, -1], y = factor(rain[["RainTomorrow"]]))
table(rain_balanced$RainTomorrow)
logit_model <- glm(rain_balanced$RainTomorrow ~ ., data = rain_balanced, family = binomial)
logit_model <- stepAIC(logit_model, direction = "backward", k = log(nrow(rain_balanced)), trace = FALSE)
head(rain_balanced)
head(rain_balanced)
head(rain)
head(rain_n)
prop.table(table(rain_n$RainTomorrow))
rain_balanced <- downSample(x = rain_n[, -1], y = factor(rain[["RainTomorrow"]]))
table(rain_balanced$RainTomorrow)
head(rain_balanced)
balancedRAIN <- SmoteClassif(rain_n$RainTomorrow ~ ., rain[], C.perc = "balance", dist="HEOM")
table(rain_n$RainTomorrow)
table(balancedRAIN$RainTomorrow)
head(balancedRAIN)
logit_model <- glm(balancedRAIN$RainTomorrow ~ ., data = balancedRAIN, family = binomial)
balancedRAIN$RainTomorrow <- as.numeric(balancedRAIN$RainTomorrow)
head(balancedRAIN)
logit_model <- glm(balancedRAIN$RainTomorrow ~ ., data = balancedRAIN, family = binomial)
logit_model <- stepAIC(logit_model, direction = "backward", k = log(nrow(rain_balanced)), trace = FALSE)
summary(logit_model)
head(logit_model)
summary(logit_model)
balancedRAIN <- SmoteClassif(rain_n$RainTomorrow ~ ., rain_n[], C.perc = "balance", dist="HEOM")
table(rain_n$RainTomorrow)
table(balancedRAIN$RainTomorrow)
head(balancedRAIN)
balancedRAIN$RainTomorrow <- as.numeric(balancedRAIN$RainTomorrow)
logit_model <- glm(balancedRAIN$RainTomorrow ~ ., data = balancedRAIN, family = binomial)
logit_model <- stepAIC(logit_model, direction = "backward", k = log(nrow(rain_balanced)), trace = FALSE)
summary(logit_model)
rain_subset <- balancedRAIN[, c("MinTemp", "Rainfall", "Sunshine", "WindGustSpeed", "WindSpeed9am", "WindSpeed3pm", "Humidity3pm", "Pressure9am", "Pressure3pm", "Cloud3pm", "Temp9am", "RainToday", "RainTomorrow")]
install.packages("rsample")
library(rsample)
set.seed(123)
split <- initial_split(rain_subset, prob = 0.75)
train <- training(split)
test <- testing(split)
train_2 <- sample(1:nrow(rain_subset), nrow(rain_subset) * 0.75)
# Calculate the test indices
test_2 <- setdiff(1:nrow(rain_subset), train_2)
# Split the target variable into train and test sets
rain_subset.train_2 <- rain_subset[train_2]
train_2 <- sample(1:nrow(rain_subset), nrow(rain_subset) * 0.75)
test_2 <- setdiff(1:nrow(rain_subset), train_2)
rain_subset.train_2 <- rain_subset[train_2]
rain_subset.train_2 <- rain_subset[[train_2]]
rain_subset.train_2 <- rain_subset[train_2,]
rain_subset.train_2 <- rain_subset[train_2,]
rain_subset.test_2 <- rain_subset[test_2,]
head(rain_subset.train_2)
head(rain_subset.test_2)
head(rain_subset.train)
head(train)
head(test)
rain_subset.isna
rain_subset.isna()
isna(rain_subset)
is.na(rain_subset)
sum(is.na(rain_subset)==TRUE)
sum(is.na(balancedRAIN)==TRUE)
sum(is.na(rain_n)==TRUE)
prop.table(table(rain_n$RainTomorrow))
balancedRAIN <- SmoteClassif(rain_n$RainTomorrow ~ ., rain_n[], C.perc = "balance", dist="HEOM")
table(rain_n$RainTomorrow)
table(balancedRAIN$RainTomorrow)
head(balancedRAIN)
sum(is.na(balancedRAIN))
sum(is.na(balancedRAIN$RainTomorrow))
head(rain_n)
print(unique(rain_n$RainTomorrow))
print(unique(balancedRAIN$RainTomorrow))
table(balancedRAIN$RainTomorrow)
table(rain_n$RainTomorrow)
rain_balanced <- downSample(x = -rain_n$RainTomorrow, y = rain_n$RainTomorrow)
rain_balanced <- downSample(x = -rain_n$RainTomorrow, y = factor(rain_n[["RainTomorrow"]]))
table(rain_balanced$RainTomorrow)
head(rain_balanced)
rain_balanced <- downSample(x = rain_n[,-rain_n$RainTomorrow], y = factor(rain_n[["RainTomorrow"]]))
table(rain_balanced$RainTomorrow)
head(rain_balanced)
rain_balanced <- downSample(x = rain_n[, -which(names(rain_n) == "RainTomorrow")],
y = factor(rain_n$RainTomorrow),
yname = "RainTomorrow")table(rain_balanced$RainTomorrow)
rain_balanced <- downSample(x = rain_n[, -which(names(rain_n) == "RainTomorrow")],
y = factor(rain_n$RainTomorrow),
yname = "RainTomorrow")table(rain_balanced$RainTomorrow))
rain_balanced <- downSample(x = rain_n[, -which(names(rain_n) == "RainTomorrow")],
y = factor(rain_n$RainTomorrow),
yname = "RainTomorrow")
table(rain_balanced$RainTomorrow)
head(rain_balanced)
sum(is.na(rain_balanced$RainTomorrow))
logit_model <- glm(rain_balanced$RainTomorrow ~ ., data = rain_balanced, family = binomial)
logit_model <- stepAIC(logit_model, direction = "backward", k = log(nrow(rain_balanced)), trace = FALSE)
summary(logit_model)
rain_subset <- rain_balanced[, c("MinTemp", "Sunshine", "WindGustSpeed", "WindSpeed9am", "WindSpeed3pm", "Humidity3pm", "Pressure9am", "Pressure3pm", "Cloud9am", "Cloud3pm", "Temp3pm", "RainToday", "RainTomorrow")]
set.seed(123)
train_2 <- sample(1:nrow(rain_subset), nrow(rain_subset) * 0.75)
# Calculate the test indices
test_2 <- setdiff(1:nrow(rain_subset), train_2)
# Split the target variable into train and test sets
rain_subset.train_2 <- rain_subset[train_2,]
rain_subset.test_2 <- rain_subset[test_2,]
head(rain_subset.train_2)
head(rain_subset.test_2)
sum(is.na(rain_subset.train_2))
sum(is.na(rain_subset.test_2))
set.seed(123)
# split <- initial_split(rain_subset, prob = 0.75)
# train <- training(split)
# test <- testing(split)
train <- sample(1:nrow(rain_subset), nrow(rain_subset) * 0.75)
# Calculate the test indices
test <- setdiff(1:nrow(rain_subset), train_2)
# Split the target variable into train and test sets
rain_subset_train <- rain_subset[train,]
rain_subset_test <- rain_subset[test,]
head(rain_subset_train)
head(rain_subset_test)
summary(rain_subset)
head(rain_subset)
model <- glm(rain_subset_train$RainTomorrow ~ ., data = rain_subset)
head(rain_subset_train)
model <- glm(data = rain_subset_train,
rain_subset_train$RainTomorrow ~ .,
family = binomial)
glm_model <- glm(data = rain_subset_train,
rain_subset_train$RainTomorrow ~ .,
family = binomial)
model_summary <- summary(glm_model)
summary(glm_model)
summary(glm_model)
glm_r2 <- 1 - (model_summary$deviance/model_summary$null.deviance)
1/(1-glm_r2)
model_summary$rsq
1/(1-glm_r2)
glm_r2
model_summary$rss
summary(glm_model)
r2 <- 1 - (model_summary$deviance/model_summary$null.deviance)
vif <- 1/(1-r2)
print(r2)
print(vif)
glm_predict = predict(glm_model, test, type = "response")
glm_predict = predict(glm_model, rain_subset_test, type = "response")
print(glm_predict[0:12])
glm_predict <- predict(glm_model, rain_subset_test, type = "response")
glm_predict_5<- ifelse(glm_predict > threshold5, 1, 0)
threshold5 <- 0.5
threshold6 <- 0.6
threshold7 <- 0.7
glm_predict_5<- ifelse(glm_predict > threshold5, 1, 0)
glm_predict_6<- ifelse(glm_predict > threshold6, 1, 0)
glm_predict_7<- ifelse(glm_predict > threshold7, 1, 0)
table(glm_predict_5)
table(glm_predict_5)
table(glm_predict_6)
table(glm_predict_7)
table(rain_subset_test$RainTomorrow, glm_predict_5)
mean(glm_predict_5!=rain_subset_test$RainTomorrow)
# Confusion matrix with threshold = 0.5
table(rain_subset_test$RainTomorrow, glm_predict_5)
mean(glm_predict_5!=rain_subset_test$RainTomorrow)
# Confusion matrix with threshold = 0.6
table(rain_subset_test$RainTomorrow, glm_predict_6)
mean(glm_predict_6!=rain_subset_test$RainTomorrow)
# Confusion matrix with threshold = 0.7
table(rain_subset_test$RainTomorrow, glm_predict_7)
mean(glm_predict_7!=rain_subset_test$RainTomorrow)
cm5 <- confusionMatrix(data = glm_predict_5, reference = rain_subset_test$RainTomorrow)
cm5 <- confusionMatrix(data = glm_predict_5, reference = factor(rain_subset_test$RainTomorrow)
cm5 <- confusionMatrix(data = glm_predict_5, reference = factor(rain_subset_test$RainTomorrow)
cm5 <- confusionMatrix(data = glm_predict_5, reference = factor(rain_subset_test$RainTomorrow))
cm5 <- confusionMatrix(data = factor(glm_predict_5), reference = factor(rain_subset_test$RainTomorrow))
plot(cm5)
print(cm5)
cm_table <- as.data.frame(cm5$table)
# Plot the confusion matrix using ggplot2
ggplot(data = cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
geom_tile(color = "white") +
geom_text(aes(label = Freq), color = "black", size = 12) +
scale_fill_gradient(low = "white", high = "steelblue") +
labs(title = "Confusion Matrix", x = "Reference", y = "Prediction") +
theme_minimal() +
theme(axis.text = element_text(size = 12),
plot.title = element_text(size = 16, face = "bold"))
cm_table_5 <- as.data.frame(cm5$table)
# Plot the confusion matrix using ggplot2
plot_confusion_matrix <- function(cm_table) {
ggplot(data = cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
geom_tile(color = "white") +
geom_text(aes(label = Freq), color = "black", size = 12) +
scale_fill_gradient(low = "white", high = "steelblue") +
labs(title = "Confusion Matrix", x = "Reference", y = "Prediction") +
theme_minimal() +
theme(axis.text = element_text(size = 12),
plot.title = element_text(size = 16, face = "bold"))
}
plot_confusion_matrix(cm_table_5)
threshold4 <- 0.4
threshold5 <- 0.5
threshold6 <- 0.6
glm_predict_4<- ifelse(glm_predict > threshold4, 1, 0)
glm_predict_5<- ifelse(glm_predict > threshold5, 1, 0)
glm_predict_6<- ifelse(glm_predict > threshold6, 1, 0)
create_confusion_matrix <- function(confusion_matrix) {
# Extract the confusion matrix table
cm_table <- as.data.frame(confusion_matrix$table)
# Plot the confusion matrix using ggplot2
ggplot(data = cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
geom_tile(color = "white") +
geom_text(aes(label = Freq), color = "black", size = 12) +
scale_fill_gradient(low = "white", high = "steelblue") +
labs(title = "Confusion Matrix", x = "Reference", y = "Prediction") +
theme_minimal() +
theme(axis.text = element_text(size = 12),
plot.title = element_text(size = 16, face = "bold"))
}
table(rain_subset_test$RainTomorrow, glm_predict_4)
mean(glm_predict_4!=rain_subset_test$RainTomorrow)
cm4 <- confusionMatrix(data = factor(glm_predict_4), reference = factor(rain_subset_test$RainTomorrow))
# Confusion matrix with threshold = 0.5
table(rain_subset_test$RainTomorrow, glm_predict_5)
mean(glm_predict_5!=rain_subset_test$RainTomorrow)
cm5 <- confusionMatrix(data = factor(glm_predict_5), reference = factor(rain_subset_test$RainTomorrow))
# Confusion matrix with threshold = 0.6
table(rain_subset_test$RainTomorrow, glm_predict_6)
mean(glm_predict_6!=rain_subset_test$RainTomorrow)
cm6 <- confusionMatrix(data = factor(glm_predict_6), reference = factor(rain_subset_test$RainTomorrow))
a <- create_confusion_matrix(cm4)
b <- create_confusion_matrix(cm5)
c <- create_confusion_matrix(cm6)
grid.arrange(grobs = c(a, b, c), nrow = 1)
cm_all = list(a, b, c)
grid.arrange(grobs = cm_all, nrow = 1)
grid.arrange(grobs = cm_all, nrow = 3)
grid.arrange(grobs = cm_all, nrow = 3, scales = "fixed")
plot_width <- c(4, 4, 4)
grid.arrange(grobs = cm_all, nrow = 3, widths = plot_width)
create_confusion_matrix <- function(confusion_matrix) {
# Extract the confusion matrix table
cm_table <- as.data.frame(confusion_matrix$table)
# Plot the confusion matrix using ggplot2
ggplot(data = cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
geom_tile(color = "white") +
geom_text(aes(label = Freq), color = "black", size = 8) +
scale_fill_gradient(low = "white", high = "steelblue") +
labs(title = "Confusion Matrix", x = "Reference", y = "Prediction") +
theme_minimal() +
theme(axis.text = element_text(size = 8),
plot.title = element_text(size = 8, face = "bold"))
}
# Confusion matrix with threshold = 0.4
table(rain_subset_test$RainTomorrow, glm_predict_4)
mean(glm_predict_4!=rain_subset_test$RainTomorrow)
cm4 <- confusionMatrix(data = factor(glm_predict_4), reference = factor(rain_subset_test$RainTomorrow))
# Confusion matrix with threshold = 0.5
table(rain_subset_test$RainTomorrow, glm_predict_5)
mean(glm_predict_5!=rain_subset_test$RainTomorrow)
cm5 <- confusionMatrix(data = factor(glm_predict_5), reference = factor(rain_subset_test$RainTomorrow))
# Confusion matrix with threshold = 0.6
table(rain_subset_test$RainTomorrow, glm_predict_6)
mean(glm_predict_6!=rain_subset_test$RainTomorrow)
cm6 <- confusionMatrix(data = factor(glm_predict_6), reference = factor(rain_subset_test$RainTomorrow))
a <- create_confusion_matrix(cm4)
b <- create_confusion_matrix(cm5)
c <- create_confusion_matrix(cm6)
cm_all = list(a, b, c)
plot_width <- c(4, 4, 4)
grid.arrange(grobs = cm_all, nrow = 3)
grid.arrange(grobs = cm_all, nrow = 1, width = plot_width)
grid.arrange(grobs = cm_all, nrow = 3, width = plot_width)
create_confusion_matrix <- function(confusion_matrix) {
# Extract the confusion matrix table
cm_table <- as.data.frame(confusion_matrix$table)
# Plot the confusion matrix using ggplot2
ggplot(data = cm_table, aes(x = Reference, y = Prediction, fill = Freq)) +
geom_tile(color = "white") +
geom_text(aes(label = Freq), color = "black", size = 8) +
scale_fill_gradient(low = "white", high = "steelblue") +
labs(title = "Confusion Matrix", x = "Target", y = "Prediction") +
theme_minimal() +
theme(axis.text = element_text(size = 8),
plot.title = element_text(size = 8, face = "bold"))
}
a <- create_confusion_matrix(cm4)
b <- create_confusion_matrix(cm5)
c <- create_confusion_matrix(cm6)
cm_all = list(a, b, c)
plot_width <- c(4, 4, 4)
grid.arrange(grobs = cm_all, nrow = 3, width = plot_width)
print(cm4)
print(cm5)
