---
title: "Rainfall_Predict"
author: "Sofia Trogu"
date: "2023-06-02"
output: pdf_document
---

```{r import}
library(corrplot)
library(ggplot2)
library(caret)
library(magrittr)
library(gridExtra)  
library(scales)
library(DMwR)
library(UBL)
library(caret)
library(MASS)
library(ipred)
```

## Download the Rain Dataset
```{r data loading}
file_path <- "/Users/Sofia/Desktop/Rain_Australia/weatherAUS.csv"
rain <- read.csv(file_path)
head(rain)
summary(rain)
```

## Data Preprocessing

```{r data preprocessing}
# Find Empty Columns
empty_columns <- which(colSums(is.na(rain)) == nrow(rain))
names_of_empty_col<- names(rain)[empty_columns]
names_of_empty_col

dim(rain)

# Omit rows with NAs. We are left with 56,420 rows and 23 columns
rain <- na.omit(rain)
print(rain)

rain$RainToday <- ifelse(rain$RainToday == "Yes", 1,
                                     ifelse(rain$RainToday == "No", 0, rain$RainToday))

#RainTomorrow is our Target variable                         
rain$RainTomorrow <- ifelse(rain$RainTomorrow == "Yes", 1,
                                     ifelse(rain$RainTomorrow == "No", 0, rain$RainToday))  

#Remove date and location columns and hot encode wind directions
rain <- rain[, !(names(rain) %in% c('Date', 'Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm'))]

# 56,420 Ã— 18
head(rain)

rain <- as.data.frame(lapply(rain, as.numeric))
print(summary(rain))
```
## Correlation 
```{r correlation}
# Build a Correlation Matrix
cor_matrix <- cor(rain)

# Create a heatmap from the correlation matrix with blue, white, and green color scheme
heatmap(cor_matrix, col = colorRampPalette(c("blue", "white", "green"))(100))

# Add a color legend
legend_colors <- c("blue", "white", "green")
legend("right", legend = c(-1, 0, 1), fill = legend_colors, title = "Correlation")

# Add a main title
title(main = "Correlation Heatmap")

corrplot <- corrplot(cor(rain[,-19]),
             method = "number",
             diag = TRUE,
             tl.cex = 0.4,
             number.cex = 0.5,
             tl.col = "black")
```
## Density Plots

```{r density}
## Find features with highest correlation with target variable (RainTomorrow)

correlations <- cor_matrix['RainTomorrow',]
highly_correlated_columns <- correlations[abs(correlations) > 0.3 & correlations != 1] 
column_names <- names(highly_correlated_columns)
print(column_names)

rain_subset <- rain[,c(column_names)]

# We are trying to visualize relationship between Target Variable, RainTomorrow with the features having the highest correlation

# Calculate the count of each feature
count_rain_today <- sum(rain$RainToday == 1)
count_no_rain_today <- sum(rain$RainToday == 0)
count_rain_tomorrow <- sum(rain$RainTomorrow == 1)
count_no_rain_tomorrow <- sum(rain$RainTomorrow == 0)

# Create a data frame with the counts
count_df <- data.frame(
  Feature = c("RainToday", "RainTomorrow", "RainToday","RainTomorrow"),
  Value = c("1", "1", "0", "0"),
  Count = c(count_rain_today, count_rain_tomorrow, count_no_rain_today, count_no_rain_tomorrow)
)

plot_list <- list()

for (col in column_names) {
  if (col == "RainToday") {
    # Plot the barplot
    bar_plot <- ggplot(count_df, aes(x = Value, y = Count, fill = Feature)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Feature", y = "Count", fill = "") +
    scale_fill_manual(values = c("red", "blue"), labels = c("RainToday", "RainTomorrow")) +
    theme_minimal()
    plot_list <- append(plot_list, list(bar_plot))
  }
  else {
    density_plot <- rain%>% ggplot(aes(x = .data[[col]] , fill = factor(RainTomorrow))) +
    geom_density(alpha = 0.5) +
    labs(x = col, y = "Density", fill = "RainTomorrow") +
    ggtitle(paste("Density Plot of ", col, "by Raintomorrow")) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size =10))
  plot_list <- append(plot_list, list(density_plot))
  }
  
}
print(plot_list)
grid.arrange(grobs = plot_list, nrow = 3, ncol = 2)

# Sunshine: fraction of total days having higher sunshine record more 0 RainTomorrow, lower sunshine, more 1 RainTomorrow
# Humidity3pm: overlap more but still higher humidity associated with 1 RainTomorrow and vice versa
#Cloud9am/Cloud3pm: oscillates a bit across x-axis with higher discrepancies between RainTomorrow values at the two extremes.  
#RainToday: Since RainToday is a binary variable, the density plots are concentrated around 0 and 1. When RainToday =0, there is a bigger discrepancy between 0 and 1 for RainTomorrow. 

```
## Feature Scaling and Balancing

```{r balancing and feature scaling}

# Check distribution of RainTomorrow values to see how balanced the data is
# 0: 43993; 1: 12427 
table(rain$RainTomorrow)

# Handling balancing of data below in train/test split

# Feature Scaling

```
## Feature Selection (Backward and Forward using BIC)
```{r feature selection}

# Perform logistic regression with forward stepwise selection
logit_model <- glm(Salary ~ 1, data = Hitters, family = binomial)  # Start with a null model

# Perform forward stepwise selection using AIC
logit_model <- stepAIC(logit_model, direction = "forward", scope = formula(Hitters[, -1]), trace = FALSE)

# Print the summary of the logistic regression model
summary(logit_model)
```
## Splitting Data into Train and Test
```{r split data}
# Percentage of each class in RainTomorrow
prop.table(table(rain$RainTomorrow))

balancedRAIN <- SmoteClassif(rain$RainTomorrow ~ ., rain[], C.perc = "balance", dist="HEOM")
table(rain$RainTomorrow)
table(balancedRAIN$RainTomorrow)


#newData <- SMOTE(as.factor(rain$RainTomorrow) ~ ., rain, perc.over = 100,perc.under=300)

#Downsamples majority class(0) 
under <- downSample(x = rain[, -1], y = factor(rain[["RainTomorrow"]]))
table(under$RainTomorrow)

```
## Models
```{r models}
```
## Plots and Analysis
```{r plots/analysis}
```