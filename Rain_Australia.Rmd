---
title: "Rainfall_Predict"
author: "Sofia Trogu"
date: "2023-06-02"
output: pdf_document
---

```{r import}
library(corrplot)
library(ggplot2)
library(caret)
library(magrittr)
library(gridExtra)  
library(scales)
library(DMwR)
library(UBL)
library(caret)
library(MASS)
library(ipred)
library(rsample)
```

## Download the Rain Dataset
```{r data loading}
file_path <- "/Users/Sofia/Desktop/Rain_Australia/weatherAUS.csv"
rain <- read.csv(file_path)
head(rain)
summary(rain)
```

## Data Preprocessing

```{r data preprocessing}
# Find Empty Columns
empty_columns <- which(colSums(is.na(rain)) == nrow(rain))
names_of_empty_col<- names(rain)[empty_columns]
names_of_empty_col

dim(rain)

# Omit rows with NAs. We are left with 56,420 rows and 23 columns
rain <- na.omit(rain)
print(rain)

rain$RainToday <- ifelse(rain$RainToday == "Yes", 1,
                                     ifelse(rain$RainToday == "No", 0, rain$RainToday))

#RainTomorrow is our Target variable                         
rain$RainTomorrow <- ifelse(rain$RainTomorrow == "Yes", 1,
                                     ifelse(rain$RainTomorrow == "No", 0, rain$RainToday))  

#Remove date and location columns and hot encode wind directions
rain <- rain[, !(names(rain) %in% c('Date', 'Location', 'WindGustDir', 'WindDir9am', 'WindDir3pm'))]

# 56,420 Ã— 18
head(rain)

rain <- as.data.frame(lapply(rain, as.numeric))
print(summary(rain))
```
## Correlation 
```{r correlation}
# Build a Correlation Matrix
cor_matrix <- cor(rain)

# Create a heatmap from the correlation matrix with blue, white, and green color scheme
heatmap(cor_matrix, col = colorRampPalette(c("blue", "white", "green"))(100))

# Add a color legend
legend_colors <- c("blue", "white", "green")
legend("right", legend = c(-1, 0, 1), fill = legend_colors, title = "Correlation")

# Add a main title
title(main = "Correlation Heatmap")

corrplot <- corrplot(cor(rain[,-19]),
             method = "number",
             diag = TRUE,
             tl.cex = 0.4,
             number.cex = 0.5,
             tl.col = "black")
```
## Density Plots

```{r density}
## Find features with highest correlation with target variable (RainTomorrow)

correlations <- cor_matrix['RainTomorrow',]
highly_correlated_columns <- correlations[abs(correlations) > 0.3 & correlations != 1] 
column_names <- names(highly_correlated_columns)
print(column_names)

rain_subset <- rain[,c(column_names)]

# We are trying to visualize relationship between Target Variable, RainTomorrow with the features having the highest correlation

# Calculate the count of each feature
count_rain_today <- sum(rain$RainToday == 1)
count_no_rain_today <- sum(rain$RainToday == 0)
count_rain_tomorrow <- sum(rain$RainTomorrow == 1)
count_no_rain_tomorrow <- sum(rain$RainTomorrow == 0)

# Create a data frame with the counts
count_df <- data.frame(
  Feature = c("RainToday", "RainTomorrow", "RainToday","RainTomorrow"),
  Value = c("1", "1", "0", "0"),
  Count = c(count_rain_today, count_rain_tomorrow, count_no_rain_today, count_no_rain_tomorrow)
)

plot_list <- list()

for (col in column_names) {
  if (col == "RainToday") {
    # Plot the barplot
    bar_plot <- ggplot(count_df, aes(x = Value, y = Count, fill = Feature)) +
    geom_bar(stat = "identity", position = "dodge") +
    labs(x = "Feature", y = "Count", fill = "") +
    scale_fill_manual(values = c("red", "blue"), labels = c("RainToday", "RainTomorrow")) +
    theme_minimal()
    plot_list <- append(plot_list, list(bar_plot))
  }
  else {
    density_plot <- rain%>% ggplot(aes(x = .data[[col]] , fill = factor(RainTomorrow))) +
    geom_density(alpha = 0.5) +
    labs(x = col, y = "Density", fill = "RainTomorrow") +
    ggtitle(paste("Density Plot of ", col, "by Raintomorrow")) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size =10))
  plot_list <- append(plot_list, list(density_plot))
  }
  
}
print(plot_list)
grid.arrange(grobs = plot_list, nrow = 3, ncol = 2)

# Sunshine: fraction of total days having higher sunshine record more 0 RainTomorrow, lower sunshine, more 1 RainTomorrow
# Humidity3pm: overlap more but still higher humidity associated with 1 RainTomorrow and vice versa
#Cloud9am/Cloud3pm: oscillates a bit across x-axis with higher discrepancies between RainTomorrow values at the two extremes.  
#RainToday: Since RainToday is a binary variable, the density plots are concentrated around 0 and 1. When RainToday =0, there is a bigger discrepancy between 0 and 1 for RainTomorrow. 

```
## Feature Scaling

```{r feature scaling}

# Check distribution of RainTomorrow values to see how balanced the data is
# 0: 43993; 1: 12427 
table(rain$RainTomorrow)

# Handling balancing of data below in train/test split

# Feature Scaling
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}

rain_n <- as.data.frame(lapply(rain[,1:16], min_max_norm))

#Add back in Binary Feature, RainToday and target variable
rain_n$RainToday <- rain$RainToday
rain_n$RainTomorrow <- rain$RainTomorrow

```

## Balancing
```{r balancing}
#Downsamples majority class(0) 
#Added yname to specify the target variable in downSample function, ow it assumes first col is target
rain_balanced <- downSample(x = rain_n[, -which(names(rain_n) == "RainTomorrow")], 
                            y = factor(rain_n$RainTomorrow), 
                            yname = "RainTomorrow")
table(rain_balanced$RainTomorrow)
head(rain_balanced)

#Check if there are any NAs
sum(is.na(rain_balanced$RainTomorrow))

```
## Feature Selection (Backward and Forward using BIC)
```{r feature selection}

# Perform logistic regression with forward stepwise selection
logit_model <- glm(rain_balanced$RainTomorrow ~ ., data = rain_balanced, family = binomial)  

# Perform forward stepwise selection using AIC with log(n)
logit_model <- stepAIC(logit_model, direction = "backward", k = log(nrow(rain_balanced)), trace = FALSE)

# Print the summary of the logistic regression model
summary(logit_model)

# Subset the dataframe with the chosen features based on stepwise selection
rain_subset <- rain_balanced[, c("MinTemp", "Sunshine", "WindGustSpeed", "WindSpeed9am", "WindSpeed3pm", "Humidity3pm", "Pressure9am", "Pressure3pm", "Cloud9am", "Cloud3pm", "Temp3pm", "RainToday", "RainTomorrow")]
                            
```
#Train/Test Split
```{r train/test split}

set.seed(123)

# split <- initial_split(rain_subset, prob = 0.75)
# train <- training(split)
# test <- testing(split)

train <- sample(1:nrow(rain_subset), nrow(rain_subset) * 0.75)

# Calculate the test indices
test <- setdiff(1:nrow(rain_subset), train_2)

# Split the target variable into train and test sets
rain_subset_train <- rain_subset[train,]
rain_subset_test <- rain_subset[test,]

head(rain_subset_train)
head(rain_subset_test)
```
## Selected Model
```{r selected model}
model <- glm(balancedRAIN$RainTomorrow ~ MinTemp + Rainfall + 
              Sunshine + WindGustSpeed + WindSpeed9am + WindSpeed3pm + 
              Humidity3pm + Pressure9am + Pressure3pm + Cloud3pm + Temp9am + 
              RainToday, family = binomial, data = balancedRAIN)
```
## Plots and Analysis
```{r plots/analysis}
```